# -*- coding: utf-8 -*-
"""Funciones.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yuBUBeQz4Ro0YjfUsNEozAqVbdHHksIR

# Funciones

1. Reproduccir la siguiente pagina [ACF - Python](https://www.alpharithms.com/autocorrelation-time-series-python-432909/)

2. Convertir °C a Kelvin
3. Calcular CV (Coeficiente de variación)
4. Seleccionar un tamaño de muestra
5. Convetir absorbancia en transmitancia
6. Convertir coordenadas rectangulares a polares

## 1. Página ACF
"""

import pandas as pd
from matplotlib import pyplot as plt
from statsmodels.graphics.tsaplots import plot_acf

df = pd.read_csv('TSLA.csv')
f = df[['Date', 'Adj Close']].set_index(['Date'])
#View data
df

del(df['Open'])
df
del(df['High'])
del(df['Low'])
del(df['Close'])
del(df['Volume'])
df


plt.show()

"""Nos dice si hay o no valores nulos"""

# Check if any null or NaN values in data
>>> df.isnull().sum()

plt.plot(df['Date'], df['Adj Close'])

"""Para la autocorrelacion"""

from statsmodels.graphics.tsaplots import plot_acf
import matplotlib.pyplot as plt

# Note: Limiting Lags to 50
plot_acf(df['Adj Close'], lags=40)

"""Lo que esta en la region sombreada no presenta una relacion significativa con el valor actual del precio 

Importante para encontrar tendencias estacionales o naturales

## 2. Función ºC a K
"""

convertir = lambda temperatura : temperatura+273.15
convertir(10)

"""## 3. Calcular CV"""

import numpy as np

cv = lambda x: np.std(x, ddof = 1) / np.mean(x) *100

tomates = [88, 85, 82, 97, 67, 77, 74, 86, 81, 95, 77, 88, 85, 76, 81, 82]

cv(tomates)

"""## 4. Seleccionar un tamaño de muestra """

from seaborn import load_dataset

df = load_dataset('tips')

df.sample(30).shape

"""## 5. Convertir absorbancia en transmitancia"""

def absorbance(T, *args, **kwargs):
  if str(type(T))[8:12] != 'list':
    return f'Debes ingresar una lista de transmitancia'
  else:
    import matplotlib.pyplot as plt
    import math 
    transmittance = []
    absorbance = []
    for i in range(len(T)):
      transmittance.append(T[i])
      A = 2 - math.log10(T[i])
      absorbance.append(A)
    plt.plot(absorbance, transmittance, 'pr')
    plt.title('Transmitancia vs Absorbancia')
    plt.xlabel('Absorbancia')
    plt.ylabel('Transmitancia')
    plt.show()

import numpy

T = numpy.random.uniform(50,100,100)
absorbance(T = list(T))

"""## 6. Convertir coordenadas rectangulares a polares"""

import cmath 

rectangulares = complex (2, 3)

coordenadas_polares = cmath.polar(rectangulares)

print(coordenadas_polares)

print()

import mpmath
def cartesian_to_polar(x, y):
  r = (x**2 + y**2)**(1/2)
  theta= mpmath.cot(x/y)
  print(f'ratio = {r}, theta = {theta}')

cartesian_to_polar(1,2)